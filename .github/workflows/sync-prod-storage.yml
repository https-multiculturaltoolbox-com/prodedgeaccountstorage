name: Sync Azure Blob (chunked) to Repo

on:
  workflow_dispatch:
    inputs:
      prefixes:
        description: "Space-separated prefixes to sync (use '.' for whole container)"
        required: true
        default: "."

permissions:
  contents: write

env:
  AZURE_STORAGE_ACCOUNT: ${{ secrets.AZURE_STORAGE_ACCOUNT }}
  AZURE_CONTAINER: ${{ secrets.AZURE_CONTAINER }}

jobs:
  sync:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Configure git
        run: |
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git config gc.auto 0
          git config advice.updateSparsePath false
          git config --global --add safe.directory "$GITHUB_WORKSPACE"

      - name: Free disk (adds ~20–30GB)
        run: |
          sudo rm -rf /usr/share/dotnet || true
          sudo rm -rf /opt/ghc || true
          sudo rm -rf "/usr/local/share/boost" || true
          docker system prune -af || true
          sudo apt-get clean || true
          df -h

      - name: Install AzCopy (v10)
        run: |
          curl -sL https://aka.ms/downloadazcopy-v10-linux | tar -xz --strip-components=1
          sudo mv azcopy /usr/local/bin/azcopy
          azcopy --version

      - name: Sync in memory-safe slices (download→batch-copy→commit→drop)
        env:
          PREFIXES: ${{ github.event.inputs.prefixes }}
          AZURE_STORAGE_KEY: ${{ secrets.AZURE_STORAGE_KEY }}
        run: |
          set -euo pipefail

          : "${AZURE_STORAGE_KEY:?AZURE_STORAGE_KEY missing}"
          : "${AZURE_STORAGE_ACCOUNT:?AZURE_STORAGE_ACCOUNT missing}"
          : "${AZURE_CONTAINER:?AZURE_CONTAINER missing}"
          : "${PREFIXES:?No prefixes provided}"

          # Use the roomy /mnt for all temp
          sudo mkdir -p /mnt/aztmp
          sudo chown "$USER":"$USER" /mnt/aztmp
          export TMPDIR=/mnt/aztmp

          # AzCopy auth & tuning
          export AZCOPY_ACCOUNT_KEY="${AZURE_STORAGE_KEY}"
          export AZCOPY_CONCURRENCY_VALUE=8
          export AZCOPY_LOG_LOCATION="${RUNNER_TEMP}/azcopy-logs"
          mkdir -p "$AZCOPY_LOG_LOCATION"

          # Sparse checkout keeps the working tree tiny between slices
          git sparse-checkout init --cone || true
          mkdir -p __keep__ && : > __keep__/.keep
          git sparse-checkout set __keep__

          # Helper: add+commit+push only if changes exist
          commit_if_needed () {
            local what="$1"
            if ! git diff --cached --quiet -- .; then
              git commit -m "Sync slice: ${what} - $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
              git push
            else
              echo "No changes for ${what}."
            fi
          }

          # Move one directory or a list of files, commit, then shrink again
          process_slice () {
            local src_root="$1"   # e.g. /mnt/aztmp/root
            local rels_file="$2"  # newline-separated relative paths from src_root
            local target_prefix="$3" # repo dir prefix like "." or "./foo"

            mapfile -t rels < "$rels_file"
            [ "${#rels[@]}" -gt 0 ] || return 0

            # Expand sparse view to include these paths
            # (list each path relative to repo root)
            patterns=( "__keep__" )
            for r in "${rels[@]}"; do
              if [ "$target_prefix" = "." ]; then
                patterns+=( "$r" )
              else
                patterns+=( "${target_prefix#./}/$r" )
              fi
            done
            git sparse-checkout set -- "${patterns[@]}"

            # Copy the slice into the repo
            for r in "${rels[@]}"; do
              src="$src_root/$r"
              dst="$target_prefix/$r"
              mkdir -p "$(dirname "$dst")"
              if [ -d "$src" ]; then
                rsync -a "$src"/ "$dst"/
              else
                rsync -a "$src" "$dst"
              fi
            done

            # Stage & commit
            git add -- "${rels[@]/#/${target_prefix%/.}/}"
            commit_if_needed "${rels[0]} (+$(( ${#rels[@]} - 1 )) more)"

            # Drop slice from working tree to free space
            git sparse-checkout set __keep__
            git clean -fdx

            # Remove from temp
            for r in "${rels[@]}"; do
              rm -rf "$src_root/$r"
            done
          }

          # Turn space-separated PREFIXES into array (trim slashes)
          read -r -a PXS <<< "$PREFIXES"

          for p in "${PXS[@]}"; do
            p="${p%/}"
            if [ -z "$p" ] || [ "$p" = "/" ]; then
              continue
            fi

            if [ "$p" = "." ]; then
              SRC_URL="https://${AZURE_STORAGE_ACCOUNT}.blob.core.windows.net/${AZURE_CONTAINER}"
              TARGET_DIR="."
              LABEL="(root)"
              DEST_LOCAL="$(mktemp -d "${TMPDIR%/}/root.XXXX")"
            else
              SRC_URL="https://${AZURE_STORAGE_ACCOUNT}.blob.core.windows.net/${AZURE_CONTAINER}/${p}"
              TARGET_DIR="./$p"
              LABEL="$p"
              DEST_LOCAL="$(mktemp -d "${TMPDIR%/}/${p//\//_}.XXXX")"
            fi

            echo "==> Downloading: $LABEL  ->  $DEST_LOCAL"
            mkdir -p "$DEST_LOCAL"
            set +e
            azcopy copy "$SRC_URL" "$DEST_LOCAL" --recursive --log-level INFO
            AC=$?
            set -e
            if [ $AC -ne 0 ]; then
              echo "::warning::AzCopy returned $AC for $LABEL (see logs in $AZCOPY_LOG_LOCATION)"
            fi

            # Build immediate children list (dirs first, then files) from DEST_LOCAL
            # and feed them in slices:
            #  - each directory is its own slice
            #  - top-level files are grouped in batches of up to 200
            pushd "$DEST_LOCAL" >/dev/null

            # process directories one by one
            find . -mindepth 1 -maxdepth 1 -type d -printf '%P\n' | sort > /tmp/dirs.list
            while read -r d; do
              [ -n "$d" ] || continue
              printf '%s\n' "$d" > /tmp/slice.list
              process_slice "$DEST_LOCAL" /tmp/slice.list "$TARGET_DIR"
            done < /tmp/dirs.list

            # batch top-level files
            find . -mindepth 1 -maxdepth 1 -type f -printf '%P\n' | sort > /tmp/files.list
            if [ -s /tmp/files.list ]; then
              batch_size=200
              > /tmp/slice.list
              c=0
              while read -r f; do
                echo "$f" >> /tmp/slice.list
                c=$((c+1))
                if [ $c -ge $batch_size ]; then
                  process_slice "$DEST_LOCAL" /tmp/slice.list "$TARGET_DIR"
                  > /tmp/slice.list
                  c=0
                fi
              done < /tmp/files.list
              # remaining
              if [ -s /tmp/slice.list ]; then
                process_slice "$DEST_LOCAL" /tmp/slice.list "$TARGET_DIR"
                > /tmp/slice.list
              fi
            fi

            popd >/dev/null

            echo "==> Done prefix: $LABEL"
            rm -rf "$DEST_LOCAL"
            df -h
          done

          echo "AzCopy logs: $AZCOPY_LOG_LOCATION"
